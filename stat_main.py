#!/usr/bin/env python
import os
import sys
from command_line_parser import CommandLineParser
from makefile_source_insight import MakefileToSourceInsight
from services import listMakefiles, readTextFileLines, config
from stat_makefile_executor import StatMakefileExecutor, StatMakFileExecutorException
from stat_makfile_generator import StatMakefileGenerator
from stat_report import StatReport
from makefile_visual_studio import MakefileToVisualStudio


class StatMainEntrance(object):

    @staticmethod
    def run(commandLine=None):
        products = {productFile[:-4]: productFile for productFile in listMakefiles(config.PRODUCT_DIRECTORY)}
        parser = CommandLineParser(products.keys(), StatMainEntrance.__isProductRequired())
        entrance = StatMainEntrance(parser.parse(commandLine), products)
        entrance.__run()

    def __init__(self, args, products):
        self.__args = args
        self.__products = products

    @staticmethod
    def __isProductRequired():
        autoGeneratedMakeFile = StatMakefileGenerator.AUTO_GENERATED_MAKEFILE
        return not os.path.isfile(autoGeneratedMakeFile) or \
            list(readTextFileLines(autoGeneratedMakeFile))[1].split('=')[1].strip() != config.VERSION

    def __run(self):
        if self.__args.visual_studio:
            self.__buildVisualStudioSolution()
        elif self.__args.source_insight:
            self.__buildSourceInsightFiles()
        else:
            self.__runUserMakfiles()

    def __buildVisualStudioSolution(self):
        self.__ensureStatAutoGeneratedMakfileExists()
        builder = MakefileToVisualStudio(self.__args.mak_files[0])
        builder.buildSolutionFile()
        builder.buildProjectFile()

    def __buildSourceInsightFiles(self):
        self.__ensureStatAutoGeneratedMakfileExists()
        builder = MakefileToSourceInsight(self.__args.mak_files[0])
        builder.buildProject()

    def __runUserMakfiles(self):
        report = StatReport()
        self.__runUserMakfilesWithReport(report)
        report.completeReport()

    def __runUserMakfilesWithReport(self, report):
        if self.__args.all_products:
            self.__runUserMakfilesOverAllProducts(report)
        else:
            self.__runUserMakfilesOverSingleProduct(report)

    def __runUserMakfilesOverAllProducts(self, report):
        for product in self.__products:
            print('\nExecuting for product [{0}]:'.format(product))
            self.__generateStatAutoGeneratedMakfile(product)
            self.__runUserMakfilesOneByOneOnce(report)

    def __runUserMakfilesOverSingleProduct(self, report):
        self.__ensureStatAutoGeneratedMakfileExists()
        self.__runUserMakfilesOneByOneOnce(report)

    def __ensureStatAutoGeneratedMakfileExists(self):
        if self.__args.product is not None:
            self.__generateStatAutoGeneratedMakfile(self.__args.product)

    def __generateStatAutoGeneratedMakfile(self, product):
        generator = StatMakefileGenerator(self.__products[product])
        generator.generate()

    def __runUserMakfilesOneByOneOnce(self, report):
        for makfile in self.__args.mak_files:
            UserMakfileRunner.run(makfile, self.__args, report)
            sys.stdout.flush()

class UserMakfileRunner(object):

    @staticmethod
    def run(makfile, commandLineArguments, report):
        print('Executing "{0}"...'.format(makfile))
        runner = UserMakfileRunner(makfile, commandLineArguments, report)
        runner.__run()


    def __init__(self, makfile, commandLineArguments, report):
        self.__makfile = makfile
        self.__args = commandLineArguments
        self.__report = report

    def __run(self):
        self.__clearIfNeeded()
        self.__runMakfileWithReportLogging()

    def __runMakfileWithReportLogging(self):
        try:
            self.__runMakfile()
            self.__reportSuccess()
        except StatMakFileExecutorException as e:
            self.__reportFailure(e.message)
        except Exception as e:
            self.__reportFailure(e)

    def __runMakfile(self):
        args = self.__args
        executor = StatMakefileExecutor(self.__makfile, beSilent=args.silent)
        executor.compile()
        if args.pack_executables:
            executor.pack()
        elif not args.compile_only:
            executor.run()

    def __reportSuccess(self):
        self.__report.addRecord(self.__makfile, 0, "")

    def __reportFailure(self, errorMessage):
        self.__report.addRecord(self.__makfile, -1, errorMessage)

    def __clearIfNeeded(self):
        if self.__shallClearAfterRun():
            StatMakefileExecutor.clear()

    def __shallClearAfterRun(self):
        return len(self.__args.mak_files) != 1 or self.__args.all_products

if __name__ == '__main__':
    try:
        StatMainEntrance.run()
    except Exception as e:
        print(e)
        print("\n=== FAILED ===")
        sys.exit(-1)
    else:
        print("\n=== PASSED ===")
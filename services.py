#!/usr/bin/env python

# SPDX-FileCopyrightText: (c) 2020 Western Digital Corporation or its affiliates,
#                             Arseniy Aharonov <arseniy.aharonov@gmail.com>
#
# SPDX-License-Identifier: MIT

import os
import platform
import subprocess
from fnmatch import filter as filterFilenames
from shutil import rmtree
from time import sleep

VERSION = '2.0.5'

def isWindows():
    return True if platform.system() == "Windows" else False

def toWindowsPath(path):
    return path.replace('/', '\\')

def toPosixPath(path):
    return path.replace('\\', '/')

def execute(commandLine):
    subprocess.Popen(commandLine, stdout = subprocess.PIPE, shell=True).wait()

def executeForOutput(commandArguments):
    commandLine = " ".join(commandArguments) if isinstance(commandArguments, (list,tuple)) else commandArguments
    items = subprocess.run(commandLine, stdout = subprocess.PIPE, shell=True).stdout
    return items.strip().decode(encoding="utf-8")

def remove(path):
    doesExist, attemptRemoval, typeName = (os.path.isdir,rmtree,'directory') if os.path.isdir(path) else (os.path.isfile, os.remove, 'file')
    while doesExist(path):
        try:
            attemptRemoval(path)
        except OSError:
            print("Waiting for {type} '{path}' to get unlocked (probably by AntiVirus)!".format(type=typeName,path=path))
            sleep(1)

def createLink(sourcePath, targetPath):
    source = os.path.relpath(sourcePath, os.path.dirname(targetPath))
    target = targetPath

    if isWindows():
        source = toWindowsPath(source)
        target = toWindowsPath(target)
        if os.path.isdir(source):
            commandLine = 'cmd /c mklink /D "{target}" "{source}"'
        else:
            commandLine = 'cmd /c mklink "{target}" "{source}"'
        execute(commandLine.format(target = target, source = source))
    else:
        os.symlink(source, target)

def findSubFolderOnPath(subFolder, path='.'):
    currentPath = os.getcwd() if path=='.' else path
    subFolderPath = os.path.join(currentPath, subFolder)
    while not os.path.isdir(subFolderPath):
        currentPath = os.path.dirname(currentPath)
        if currentPath == os.path.dirname(currentPath):
            return None
        subFolderPath = os.path.join(currentPath, subFolder)
    return subFolderPath

def getFileLocationThroughoutCurrentPath(fileName, currentPath = '.'):
    previousDirectory = None
    currentDirectory = currentPath if currentPath != '.' else os.getcwd()
    while previousDirectory != currentDirectory:
        fileLocation = os.path.join(currentDirectory, fileName)
        if os.path.isfile(fileLocation):
            return fileLocation
        previousDirectory = currentDirectory
        currentDirectory = os.path.dirname(previousDirectory)
    return None

def listMakefiles(pathName, *patterns):
    allFiles = filterFilenames(os.listdir(pathName), '*.mak')
    if patterns:
        selected = __selectFilesByPatterns(allFiles, patterns)
    else:
        selected = set(allFiles)
    ignored = __selectIgnoredFiles(allFiles, pathName)
    if ignored:
        selected.difference_update(ignored)
    return sorted(selected)

def readTextFileLines(filePath):
    _file = open(filePath)
    for line in _file.readlines():
        yield line.rstrip()
    else:
        _file.close()

def __selectIgnoredFiles(makefiles, pathName):
    statIgnoreFile = os.path.join(pathName, '.statignore')
    if os.path.exists(statIgnoreFile):
        ignoreFile = open(statIgnoreFile, 'r')
        ignoreList = [line.strip() for line in ignoreFile.readlines()]
        ignoreFile.close()
        if ignoreList:
            return __selectFilesByPatterns(makefiles, ignoreList)
    return set()

def __selectFilesByPatterns(makefiles, patterns):
    filtered = []
    for pattern in patterns:
        filtered.extend(filterFilenames(makefiles, pattern))
    return set(filtered)

class CustomSingleton(object):
    __instance = None

    @classmethod
    def __new__(cls, *args):
        if cls.__instance is None:
            cls.__instance = object.__new__(cls)
        return cls.__instance

class StatConfiguration(CustomSingleton):
    VERSION = VERSION
    RESOURCES_DIRECTORY = 'resources'
    DUMMIES_DIRECTORY = 'dummies'
    PRODUCT_DIRECTORY = 'products'
    LOGS_DIRECTORY = 'logs'
    OUTPUT_DIRECTORY = 'output'
    OUTPUT_SUB_DIRECTORIES = ['inc', 'obj', 'bin']
    PACKED_DIRECTORY = OUTPUT_DIRECTORY + '/packed'
    AV_BYPASS_DIRECTORY = OUTPUT_DIRECTORY + '/bypass'
    REPORT_FILENAME = "report.json"
    MASTER_INCLUDE_PATH = OUTPUT_DIRECTORY + '/inc'

    __toolDirectory = None

    @property
    def autoGeneratedMakfile(self):
        return '/'.join([self.OUTPUT_DIRECTORY, 'stat.mak'])

    @staticmethod
    def getToolDirectory():
        return os.path.dirname(os.path.relpath(__file__))

class VsTools(CustomSingleton):
    _TOOL_PREFIX = 'VS'
    _TOOL_SUFFIX = 'COMNTOOLS'
    _TOOL_PREDEFINED = _TOOL_PREFIX + _TOOL_SUFFIX
    _MAKE_TOOL = "bin\\nmake.exe"
    _FINDER_PATH_ENVIRON = 'ProgramFiles(x86)'
    _FINDER_TOOL = "\\Microsoft Visual Studio\\Installer\\vswhere.exe"
    _FINDER_ARGS = ' -property "installationPath" -legacy -prerelease -latest'

    _toolChainPathCache = None

    NMAKE_ARGUMENTS = "/S /NOLOGO /ERRORREPORT:NONE /F"
    PREDEFINED_TOOL_ENVIRON = _TOOL_PREFIX + _TOOL_SUFFIX

    def getToolChainPath(self):
        if self._toolChainPathCache is None:
            self._toolChainPathCache = findSubFolderOnPath('VC', self._findInstallationPath())
        return self._toolChainPathCache

    def getMakeToolLocation(self):
        return os.path.join(self.getToolChainPath(), self._MAKE_TOOL)

    def _findInstallationPath(self):
        toolChain = os.environ.get(self._TOOL_PREDEFINED, '')
        if toolChain is '':
            #toolChain = self.__attemptInstallationPathSearchWithVsTool()
            if toolChain is '':
                toolChain = self.__attemptInstallationPathSearchWithVsEnvironmentValues()
                if toolChain is '':
                    raise ServicesException(ServicesException.NO_VS_TOOLS_FOUND)
        return toolChain

    def __attemptInstallationPathSearchWithVsTool(self):
        vsFinder = os.environ.get(self._FINDER_PATH_ENVIRON, '') + self._FINDER_TOOL
        if os.path.isfile(vsFinder):
            try:
                return executeForOutput(vsFinder + self._FINDER_ARGS)
            except subprocess.CalledProcessError:
                return ''

    def __attemptInstallationPathSearchWithVsEnvironmentValues(self):
        toolChains = {value[len(self._TOOL_PREFIX):-len(self._TOOL_SUFFIX)]: os.environ.get(value) for value in
                      os.environ if value.startswith(self._TOOL_PREFIX) and value.endswith(self._TOOL_SUFFIX)}

        return toolChains[max(toolChains, key=int)] if toolChains else ''


class ServicesException(Exception):
    """
    Custom exception for STAT services
    """
    NO_VS_TOOLS_FOUND = "No VS TOOLS were found on this PC."
    NO_NMAKE_FOUND = "No NMAKE was found on this PC."


vsTools = VsTools()
config = StatConfiguration()

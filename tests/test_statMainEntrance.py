import os

from shutil import rmtree, copyfile

from services import listMakefiles, config, StatConfiguration
from stat_main import StatMainEntrance
from stat_makefile_executor import StatMakFileExecutorException
from stat_makfile_generator import StatMakefileGenerator
from stat_report import StatReport, StatReportException
from testing_tools import FileBasedTestCase, readFileLines
from testing_tools import patch, call

def _isDebuggerCall(callEntry):
    callDescription = tuple(callEntry)[0]
    result = callDescription.find('__str__')
    return result >= 0

class TestStatMainEntrance(FileBasedTestCase):
    CUT = 'stat_main'
    AVAILABLE_PRODUCTS = ['product', "product_derived"]
    PRODUCT_NAME = AVAILABLE_PRODUCTS[1]
    PRODUCT_FILE = "{0}.mak".format(PRODUCT_NAME)
    EXAMPLE_MAKFILE = "full_example.mak"
    MAKFILE_EXECUTOR_PATCH = {'target':'{cut}.StatMakefileExecutor'.format(cut=CUT), 'autospec':True}
    MAKFILE_TO_SOURCE_INSIGHT_PATCH = {'target': '{cut}.MakefileToSourceInsight'.format(cut=CUT), 'autospec': True}

    def setUp(self):
        self.skipWindowsTest() # TODO: Fix these tests for Linux

    def tearDown(self):
        if os.path.isfile(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE):
            os.remove(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE)
        if os.path.isdir(config.LOGS_DIRECTORY):
            rmtree(config.LOGS_DIRECTORY)
        if os.path.isfile(StatReport.REPORT_FILENAME):
            os.remove(StatReport.REPORT_FILENAME)

    @patch(**MAKFILE_EXECUTOR_PATCH)
    def test_singleUserMakfileUponAutoGeneratedMakfile(self, statMakefileExecutor):
        generator = StatMakefileGenerator(self.PRODUCT_FILE)
        generator.generate()
        generateMock = self.patch(self.CUT, 'StatMakefileGenerator.generate')

        StatMainEntrance.run(['-c', self.EXAMPLE_MAKFILE])

        assert generateMock.call_count == 0
        self.assertCalls(statMakefileExecutor, [call(self.EXAMPLE_MAKFILE, beSilent=False), call().compile()])
        pass

    @patch(**MAKFILE_EXECUTOR_PATCH)
    def test_singleUserMakfileUponAutoGeneratedMakfileWithWrongVersion(self, statMakefileExecutor):
        generator = StatMakefileGenerator(self.PRODUCT_FILE)
        generator.generate()
        generateMock = self.patch(self.CUT, 'StatMakefileGenerator.generate')
        self.patch(self.CUT, 'readTextFileLines', return_value=['# Makfile generated by STAT', 'TOOL_VERSION = 0.0.0'])

        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        self.assertNotEqual(0, generateMock.call_count)
        self.assertCalls(statMakefileExecutor, [call(self.EXAMPLE_MAKFILE, beSilent=False), call().compile()])
        pass

    @patch(**MAKFILE_EXECUTOR_PATCH)
    def test_cleanupBetweenProductsUponSingleProduct(self, statMakefileExecutor):
        productFiles = listMakefiles(StatConfiguration.PRODUCT_DIRECTORY)
        expected = [call.clear(), call(self.EXAMPLE_MAKFILE, beSilent=False), call().compile() ] * len(productFiles)

        StatMainEntrance.run(['-c', '--all-products', self.EXAMPLE_MAKFILE])

        self.assertCalls(statMakefileExecutor, expected)
        pass

    @patch(**MAKFILE_TO_SOURCE_INSIGHT_PATCH)
    @patch(**MAKFILE_EXECUTOR_PATCH)
    def test_handleCommandLineWithSourceInsightArguments(self, statMakefileExecutor, makfileToSourceInsight):

        StatMainEntrance.run(['-si', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        self.assertTrue(os.path.isfile(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE))
        self.assertCalls(statMakefileExecutor, [])
        self.assertCalls(makfileToSourceInsight, [call(self.EXAMPLE_MAKFILE), call().buildProject()])
        pass

    @patch('{cut}.sys.stdout.flush'.format(cut=CUT))
    @patch(**MAKFILE_EXECUTOR_PATCH)
    def test_processingAllUserMakfiles(self, statMakefileExecutor, stdoutFlush):
        allMakfiles = listMakefiles('.')
        callsPerMakfile = ((call.clear(), call(makfile, beSilent=False), call().compile()) for makfile in allMakfiles)
        expected = [aCall for makfileCalls in callsPerMakfile for aCall in makfileCalls]
        def verifyCallOrder():
            self.assertEqual(statMakefileExecutor.clear.call_count, stdoutFlush.call_count)
        stdoutFlush.side_effect = verifyCallOrder

        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME])

        self.assertEqual(statMakefileExecutor.clear.call_count, stdoutFlush.call_count)
        self.assertCalls(statMakefileExecutor, expected)
        pass

class TestStatMainEntranceLegacy(FileBasedTestCase):
    CUT = 'stat_main'
    PRODUCT_NAME = "product_derived"
    PRODUCT_FILE = "{0}.mak".format(PRODUCT_NAME)
    AVAILABLE_PRODUCTS = ['product', PRODUCT_NAME]
    EXAMPLE_MAKFILE = "full_example.mak"

    def _patch(self, objectName):
        return self.patchWithSpy(self.CUT, objectName)

    def setUp(self):
        self.skipWindowsTest() # TODO: Fix these tests for Linux
        self.spyCommandLineParser = self._patch('CommandLineParser')
        self.spyStatMakfileExecutor = self._patch('StatMakefileExecutor')
        self.spyStatMakfileGenerator = self._patch('StatMakefileGenerator')
        self.spyMakfileToVisualStudio = self._patch('MakefileToVisualStudio')

    def tearDown(self):
        if os.path.isfile(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE):
            os.remove(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE)
        if os.path.isdir(config.LOGS_DIRECTORY):
            rmtree(config.LOGS_DIRECTORY)
        if os.path.isfile(StatReport.REPORT_FILENAME):
            os.remove(StatReport.REPORT_FILENAME)

    def test__init__uponNoAutoGeneratedMakfile(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        commandLineParser = self.spyCommandLineParser.instances[0]
        arguments = commandLineParser.getArguments('__init__', callId = 0)
        self.assertSameItems(self.AVAILABLE_PRODUCTS, arguments.args[0])
        self.assertTrue(arguments.args[1])

    def test_generationOfStatAutoGeneratedMakfile(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])
        self.assertTrue(os.path.isfile(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE))

    def test_compileOnlyCommandLine(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        statMakfileExecutor = self.__retrieveMakfileExecutorSingleSpy()
        self.assertEqual(1, statMakfileExecutor.getCallCount('compile'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('run'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('pack'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('clear'))

    def test_defaultExecutionCommandLine(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        self.spyStatMakfileExecutor.addMock('run', self.__getCallbackThatChecksCompilationWasIssued())
        StatMainEntrance.run(['-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        statMakfileExecutor = self.__retrieveMakfileExecutorSingleSpy()
        self.assertEqual(1, statMakfileExecutor.getCallCount('compile'))
        self.assertEqual(1, statMakfileExecutor.getCallCount('run'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('pack'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('clear'))

    def test_compilationAndPacking(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        self.spyStatMakfileExecutor.addMock('pack', self.__getCallbackThatChecksCompilationWasIssued())
        StatMainEntrance.run(['--pack-executables', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        statMakfileExecutor = self.__retrieveMakfileExecutorSingleSpy()
        self.assertEqual(1, statMakfileExecutor.getCallCount('compile'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('run'))
        self.assertEqual(1, statMakfileExecutor.getCallCount('pack'))
        self.assertEqual(0, statMakfileExecutor.getCallCount('clear'))

    def test_allProductsCommandLine(self):
        allUserMakfiles = listMakefiles('.')
        allProductMakfiles = listMakefiles(StatConfiguration.PRODUCT_DIRECTORY)
        for product in range(len(allProductMakfiles)):
            for userFile in range(len(allUserMakfiles)):
                self.spyStatMakfileExecutor.addMock('compile',
                    self.__getCallbackThatChecksMakfileWasGenerated(allProductMakfiles[product], product))
                self.spyStatMakfileExecutor.addMock('clear', 0)

        StatMainEntrance.run(['-c', '--all-products'])

        for product in range(len(allProductMakfiles)):
            for userFile in range(len(allUserMakfiles)):
                iteration = userFile + len(allUserMakfiles) * product
                statMakfileExecutor = self.spyStatMakfileExecutor.instances[iteration]
                arguments = statMakfileExecutor.getArguments('__init__', callId=0)
                self.assertSameItems([allUserMakfiles[userFile]], arguments.args)

    def test_handlingFailureUponCompilation(self):
        allMakfiles = self.__createPreconditionWithVarietyOfPassFailResults()

        try:
            StatMainEntrance.run(['-p', self.PRODUCT_NAME] + allMakfiles)
        except StatReportException as e:
            pass
        else:
            self.fail("An exception was expexted!")

        for fileIndex in range(len(allMakfiles)):
            statMakfileExecutor = self.spyStatMakfileExecutor.instances[fileIndex]
            self.assertEqual(1, statMakfileExecutor.getCallCount('compile'))
            self.assertEqual(0 if fileIndex < 1 else 1, statMakfileExecutor.getCallCount('run'))

    def test_jsonReportCreation(self):
        expectedFile = "expected.json"
        makfiles = self.__createPreconditionWithVarietyOfPassFailResults()

        report = StatReport()
        report.addRecord(makfiles[0], -1, StatMakFileExecutorException.BUILD_FAILURE)
        report.addRecord(makfiles[1], -1, StatMakFileExecutorException.EXECUTION_FAILURE)
        for aMakfile in makfiles[2:]:
            report.addRecord(aMakfile, 0, "")
        try:
            report.completeReport()
        except StatReportException:
            pass
        copyfile(StatReport.REPORT_FILENAME, expectedFile)

        try:
            StatMainEntrance.run(['-p', self.PRODUCT_NAME] + makfiles)
        except StatReportException:
            pass

        self.assertTrue(os.path.isfile(StatReport.REPORT_FILENAME))
        self.assertSameItems(readFileLines(expectedFile), readFileLines(StatReport.REPORT_FILENAME))
        os.remove(expectedFile)

    def test_handlingUponNonExistingUserMakfile(self):
        filename = 'non_existing_filename.mak'

        report = StatReport()
        report.addRecord(filename, -1, "Makefile '{fileName}' doesn't exist!".format(fileName = filename))
        report.addRecord(filename, -1, "Makefile '{fileName}' doesn't exist!".format(fileName=filename))
        try:
            report.completeReport()
        except StatReportException:
            pass
        expectedFile = "expected.json"
        copyfile(StatReport.REPORT_FILENAME, expectedFile)

        try:
            StatMainEntrance.run(['-a', filename])
        except StatReportException:
            pass

        self.assertEqual(0, len(self.spyStatMakfileExecutor.instances))
        self.assertTrue(os.path.isfile(StatReport.REPORT_FILENAME))
        self.assertSameItems(readFileLines(expectedFile), readFileLines(StatReport.REPORT_FILENAME))
        os.remove(expectedFile)

    def test_handlingSilentOptionInCommandLine(self):
        self.spyStatMakfileExecutor.addMock('compile', 0)
        StatMainEntrance.run(['-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])
        statMakfileExecutor = self.spyStatMakfileExecutor.instances[0]
        arguments = statMakfileExecutor.getArguments('__init__', callId=0)
        self.assertFalse(arguments.beSilent)

        self.spyStatMakfileExecutor.addMock('compile', 0)
        StatMainEntrance.run(['-s', '-c', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])
        statMakfileExecutor = self.spyStatMakfileExecutor.instances[1]
        arguments = statMakfileExecutor.getArguments('__init__', callId=0)
        self.assertTrue(arguments.beSilent)

    def test_handleCommandLineWithVisualStudioArgument(self):
        self.spyMakfileToVisualStudio.addMock('buildSolutionFile', None)
        self.spyMakfileToVisualStudio.addMock('buildProjectFile', None)

        StatMainEntrance.run(['-vs', '-p', self.PRODUCT_NAME, self.EXAMPLE_MAKFILE])

        makfileToVisualStudio = self.spyMakfileToVisualStudio.instances[0]
        arguments = makfileToVisualStudio.getArguments('__init__', callId=0)
        self.assertTrue(os.path.isfile(StatMakefileGenerator.AUTO_GENERATED_MAKEFILE))
        self.assertTrue((self.EXAMPLE_MAKFILE,), arguments.args)
        self.assertEqual(0, len(self.spyStatMakfileExecutor.instances))
        self.assertEqual(1, makfileToVisualStudio.getCallCount('buildSolutionFile'))
        self.assertEqual(1, makfileToVisualStudio.getCallCount('buildProjectFile'))

    def __getCallbackThatChecksMakfileWasGenerated(self, productFile, instanceId):
        def checkMakfileWasGenerated():
            statMakfileGenerator = self.spyStatMakfileGenerator.instances[instanceId]
            arguments = statMakfileGenerator.getArguments('__init__', callId=0)
            self.assertEqual((productFile,), arguments.args)
            return 0
        return checkMakfileWasGenerated

    def __getCallbackThatChecksCompilationWasIssued(self, callCount = 1):
        def checkCompilationWasIssued():
            statMakfileExecutor = self.spyStatMakfileExecutor.instances[0]
            self.assertEqual(callCount, statMakfileExecutor.getCallCount('compile'))
            return 0
        return checkCompilationWasIssued

    def __retrieveMakfileExecutorSingleSpy(self):
        statMakfileExecutor = self.spyStatMakfileExecutor.instances[0]
        arguments = statMakfileExecutor.getArguments('__init__', callId = 0)
        self.assertSameItems([self.EXAMPLE_MAKFILE], arguments.args)
        self.assertFalse(arguments.beSilent)
        return statMakfileExecutor

    def __createPreconditionWithVarietyOfPassFailResults(self):
        allMakfiles = listMakefiles('.')
        self.assertGreaterEqual(len(allMakfiles), 3, "This test assumes at least 3 makfiles in the root!")
        def throwCompilationException():
            raise StatMakFileExecutorException(StatMakFileExecutorException.BUILD_FAILURE)
        def throwExecutionException():
            raise StatMakFileExecutorException(StatMakFileExecutorException.EXECUTION_FAILURE)

        for iteration in range(len(allMakfiles)):
            self.spyStatMakfileExecutor.addMock('compile', throwCompilationException if iteration == 0 else 0)
            if iteration == 0:
                continue
            self.spyStatMakfileExecutor.addMock('run', throwExecutionException if iteration == 1 else 0)
            if iteration == 1:
                continue
            self.spyStatMakfileExecutor.addMock('clear', 0)
        return allMakfiles

# TODO: Add test to check that joson is written correctly if a makfile is not only compiled but also ran